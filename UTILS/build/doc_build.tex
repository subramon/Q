\startreport{Documenting the Build Process}
\reportauthor{Ramesh Subramonian}

\section{Relevant Environment Variables}
\be
\item Q\_BUILD\_DIR e.g., \verb+/tmp/q/+
\item Q\_SRC\_ROOT e.g., \verb+/home/subramon/Q/+
\item Q\_ROOT e.g., \verb+/home/subramon/local/Q/+
\ee

\subsection{Derived Environment Variables}
\be
\item CDIR e.g., \verb+/tmp/q/src/+ (from Q\_BUILD\_DIR)
\item HDIR e.g., \verb+/tmp/q/include/+ (from Q\_BUILD\_DIR)
\item ODIR e.g., \verb+/tmp/q/obj/+ (from Q\_BUILD\_DIR)
\ee

\section{Make so}

The script {\tt mk\_so.lua} is called by the Makefile and calls
\be 
\item {\tt copy\_generated\_files.lua} --- 
Section~\ref{copy_generated_files}
\item {\tt mk\_q\_core\_h.lua} --- Section~\ref{mk_q_core_h}
\item {\tt o\_from\_c.lua} --- Section~\ref{o_from_c}
\item {\tt so\_from\_o.lua} --- Section~\ref{so_from_o}
\ee

\subsection{An important subtlety}

The script \verb+mk_so.lua+ gets called twice, 
once to build q\_basic and once to build q\_operators.
In both cases, it needs to create 2 things, both of which are needed so that we
can invoke C functionality from LuaJIT.
\be
\item \verb+q_core.h+ -- this is given to {\tt ffi.cdef}
\item \verb+libq_core.so+ -- this is given to {\tt ffi.load}
\ee
These are copied into the target locations e.g.,
\be
\item \verb+/home/subramon/local/Q/include/q_core.h+
\item \verb+/home/subramon/local/Q/lib/libq_core.so+
\ee

\subsection{copy generated files}
\label{copy_generated_files}

The aim of {\tt copy\_generated\_files.lua} is to get all the auto-generated 
{\tt .c} files into one directory, CDIR
and all {\tt .h} files into another directory, HDIR. It calls {\tt
recursive\_copy.lua}. 

\bi
\item Starting from a root directory (Q\_SRC\_ROOT), 
\item traverse sub-diretoriies recursively, 
\item ignoring sub-directories that do {\bf NOT} match a particular
pattern (e.g., \verb+gen_src+ or \verb+gen_inc+), 
\item copying all files that exist in
those directories to a specified destination directory (e.g., \verb+/tmp/q/src/+
or /verb+/tmp/q/include+)
\item Note that it does {\bf not} copy a file if there is no difference (based
on md5 hash) between source and destination.
\ei

If it is detected that no new .c files or .h files have been created, then
further processing is terminated. Need to think through this premature exit
carefully \TBC


What about non-auto-generated files? \TBC

\subsection{Make q\_core.h file}
\label{mk_q_core_h}

In order to enable LuaJIT, we need to cdef all the headers of all the C
functions and all the struct definitions. These are assembled into a single file
called \verb+q_core.h+

\subsubsection{struct files}
\label{struct_files}

This is an important file. If you have {\tt typedef struct} in your .h file, it
needs to be listed here. This is because we put together a bunch of .h files
into a single {\tt q\_core.h} file and then cdef that. The order in which the individual {\tt .h} files are concatenated is important.

\subsection{o from c}
\label{o_from_c}

It compiles all the {\tt .c} files available in CDIR and places 
the corresponding {\tt .o} file in ODIR. It does {\bf not} invoke gcc if the {\tt.c}
file is older than the {\tt .o} file. 


\subsubsection{Pre-requisites}
It assumes that Section~\ref{copy_generated_files} has taken care of placing
\be
\item all necessary .c files in CDIR
\item all necessary .h files in HDIR
\ee

\subsection{so from}
\label{so_from_o}
\TBC

\section{Makefile}

\subsection{Makefiles for modules}
The master Makefile calls individual Makefiles to do their work. For example,
take \verb+UTILS/src/Makefile+. It is the responsibility of this Makefile to
\be
\item generate all necessary {\tt .lua, .c, .h} files
\item auto-generated {\tt .c} files are copied into the local \verb+gen_src/+ 
\item auto-generated {\tt .h} files are copied into the local \verb+gen_inc/+ 

\item static {\tt .c} files are copied from {\tt src/} into CDIR
\item static {\tt .h} files are copied from {\tt inc/} into HDIR
\item Anything else? \TBC
\ee

The contract that each of the sub Makefiles is expected to fulfill is
\be
\item 
have a target called {\tt so}. This will cause a local \verb+.so+ file 
to be generated. This will not be used, it is created just as a 
sanity check.
\item have a target called {\tt all}. This will cause all files needed for
static compilation to be gernated but will not actually compile them. Hence, an
error could be discovered later on if the generated files are incorrect.
\item have a target called {\tt all\_for\_dc}. This will cause only the files needed for
dynamic compilation, {\bf if any}, to be generated.

\item have a target called {\tt clean}. This will cause delete all generated
files
\ee

\section{Quick Compiles for Static Build}

We don't have a very good way of doing just the work that needs to be done. That
is going to take more time and effort. That said, we have a couple of useful
``hacks''
\subsection{Modifying an operator}
Let's say that you are modifying F1F2OPF3. Then, to re-compile, you need to do 
\begin{verbatim}
cd Q/UTILS/build; rm _f1f2opf3; make 
\end{verbatim}

\subsection{Modifying a single file}
See \verb+build_hack.sh+ documented in \verb+README_build_hack.txt+

\section{Appendix}

Bogus reference: \cite{sarawagi99}
\bibliographystyle{alpha}
\bibliography{../../DOC/Q_PAPER/ref} 




