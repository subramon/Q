// START: Following is Lua's responsibility
// In particular, Lua is responsible for 
// a) creating the #define statements properly
// b) setting up data into the data structures i.e., 
// setting the values of **R, *revenue, **P, **Oa, **Ob, ...
//
// We have input data consisting of the following
/* First form of input data is Provenance */
#define nRD 4  /* number of dimensions we will slice by e.g., 
pyramid, department, state, ... TBC */
#define nR  37 /* number of item/location pairs deemed similar enough to 
                  warrant the same optimization */
uint8_t **R; // [nRD][nR];
uint8_t *revenue; // [nR];

/* Second form of input data is the perturbation parameters like
 * boh
 * tdf
 * dmd
 * ss
 * ls
 * */
#define nPD 5 // number of perturbation parameters (5 in above example)
#define nP 6875 // number of different perturbations
uint8_t **P; // [nPD][nP] 

/* Third form of input data is the values generated by the simulation */
/* These are further sub-divided into 
 * (3a) provenance independent and
 * (3b) provenance dependent 
 * We shall deal with the simpler acse of 3a first
*/
#define nOaD 8 // number of output columns = n_steps + 1 
//
// Note that for a single perturbation index, we have 1 output value 
// defined by the struct TracesSummary

float **Oa; // [nOaD][nP]
/* Note that Oa is extracted from 
typedef struct {
  float *avg_revenue; // [n_steps] 
  float *avg_units_sold; // [n_steps] 
  float num_price_changes;
  float *avg_markdowns; // [n_steps] 
} TracesSummary;
 * so that for the perturbation index by i, the following holds
 * Oa[0][i] = avg_markdowns[0]
 * Oa[1][i] = avg_markdowns[1]
 * .......
 * Oa[nOaD-2][i] = avg_markdowns[n_steps-1]
 * Oa[nOaD-1][i] = num_price_changes
*/

// Similarly, 
#define nObD 8 // number of output columns = 2*n_steps
//
float **Ob; // [nObD][nP]
/*
 * Ob[0][i] = avg_units_sold[0]
 * Ob[1][i] = avg_units_sold[1]
 * .......
 * Ob[nOBD-2][i] = avg_revenue[n_steps-2]
 * Ob[nObD-1][i] = avg_revenue[n_steps-1]
*/

// STOP: Above is Lua's responsibility
