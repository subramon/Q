// START: Following is Lua's responsibility
// In particular, Lua is responsible for 
// a) creating the #define statements properly
// b) setting up data into the data structures i.e., 
// setting the values of **R, *revenue, **P, **Oa, **Ob, ...
//
// We have input data consisting of the following
/* First form of input data is Provenance */
#define nRD 4  /* number of dimensions we will slice by e.g., 
pyramid, department, state, ... TBC */
#define nR  37 /* number of item/location pairs deemed similar enough to 
                  warrant the same optimization */
uint8_t **R; // [nRD][nR];
uint8_t *revenue; // [nR];

/* Second form of input data is the perturbation parameters like
 * boh
 * tdf
 * dmd
 * ss
 * ls
 * */
#define nPD 5 // number of perturbation parameters (5 in above example)
#define nP 6875 // number of different perturbations
uint8_t **P; // [nPD][nP] 

/* Third form of input data is the values generated by the simulation */
/* These are further sub-divided into 
 * (3a) provenance independent and
 * (3b) provenance dependent 
 * We shall deal with the simpler acse of 3a first
*/
#define nOaD 8 // number of output columns = n_steps + 1 
//
/* Note that for a single perturbation index, we have 1 output value 
   defined by the struct TracesSummary. We break these into 2 parts
   TracesASummary and TracesBSummary for exposition
typedef struct {
  float *avg_revenue; // [n_steps] 
  float *avg_units_sold; // [n_steps] 
  float num_price_changes;
  float *avg_markdowns; // [n_steps] 
} TracesSummary;
typedef struct {
  float *avg_revenue; // [n_steps] 
  float *avg_units_sold; // [n_steps] 
} TracesASummary;
typedef struct {
  float num_price_changes;
  float *avg_markdowns; // [n_steps] 
} TracesBSummary;
*/

TracesASummary *Oa; // [nP]
TracesBSummary *Ob; // [nP]

// In this implementation, we consider only pair-wise aggregation
// The composite key is represented in 32 bits, with 16 bits to represent a key
// ID and the value of that key
// Let's take an example. Consider the composite key
// ((State, California), (Department, Automotive))
// Assume that there are no more than 15 dimensions that we will slice by
// Assume that State is one of those dimensions and has 4 
// Assume that Depeartment is another of those dimensions and has 8
// Assume that California is encoded as 3 and Automotive is encoded as 1
// Then (State, California) is the 16 bits ( 4 << 12 ) | 3
// Then (Department, Automotive) is the 16 bits ( 8 << 12 ) | 1
// The entire composite key is then 
// ( ( ( 4 << 12 ) | 3 ) << 16 ) | ( ( 8 << 12 ) | 1 )
uint8_t *Rk; // [nRD]
uint8_t *Pk; // [nPD]
// so that Rk[i] gives us the key index for the ith provenance dimension
// so that Pk[i] gives us the key index for the ith perturbation dimension

// STOP: Above is Lua's responsibility
// Now C gets to work

uint32_t *comp_keys;
uint32_t n_comp_keys = ( 
    ( ( nPD * (nPD+1) ) / 2 ) + 
    ( nR * ( nRD * (nRD+1) ) / 2 ) + 
    ( nR * ( nRD * nPD ) ) );
comp_keys = malloc(n_comp_keys * sizeof(int));
return_if_malloc_failed(comp_keys);
// TODO: malloc the above
int comp_key_idx = 0;

for ( int p = 0; p < nP; p++ ) { // for each perturbation
  TracesASummary val = Oa[p];
  // create composite keys based on perturbation dimensions
  for ( int i = 0; i < nPD; i++ )  {
    uint32_t kv1 = ( Pk[i] << SHIFT_KEY ) | P[i][p];
    for ( int j = i + 1; j < nPD; j++ )  {
      uint32_t kv2 = ( Pk[j] << SHIFT_KEY ) | P[j][p];
      uint32_t comp_key = (kv1 << SHIFT_KEY_VAL) | kv2;
      comp_keys[comp_key_idx++] = comp_key;
    }
  }
  // create composite keys based on provenance dimensions
  for ( int r = 0; r < nR; r++ ) { 
    for ( int i = 0; i < nRD; i++ )  {
      uint32_t kv1 = ( Rk[i] << SHIFT_KEY ) | R[i][r];
      for ( int j = i + 1; j < nRD; j++ )  {
        uint32_t kv2 = ( Rk[j] << SHIFT_KEY ) | R[j][r];
        uint32_t comp_key = (kv1 << SHIFT_KEY_VAL) | kv2;
        comp_keys[comp_key_idx++] = comp_key;
      }
    }
  }
  // create composite keys based on provenance and perturbation
  for ( int r = 0; r < nR; r++ ) { 
    for ( int i = 0; i < nPD; i++ )  {
      uint32_t kv1 = ( Pk[i] << SHIFT_KEY ) | P[i][p];
      for ( int j = 0; j < nRD; j++ )  {
        uint32_t kv2 = ( Rk[j] << SHIFT_KEY ) | R[j][r];
        uint32_t comp_key = (kv1 << SHIFT_KEY_VAL) | kv2;
        comp_keys[comp_key_idx++] = comp_key;
      }
    }
  }
  // At this point we have populated the n_comp_keys entries in comp_keys[]
  // The "value" for all these composite keys is Oa[p]
  // We send this off to Aggregator
  // If n_comp_keys is too small, we may execute more iterations of 
  // the outer most loop until we get enough to send to Aggregator
}
