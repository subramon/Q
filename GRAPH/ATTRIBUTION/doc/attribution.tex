\startreport{Network Influence Score}
\reportauthor{Ramesh Subramonian}
\section{Introduction}

We define the ``network influence score'' problem as follows. Let us assume that
we know 2 things for every user that we have (a) who referred that user (could
be zero or one user) (b) the revenue generated by that user. 

We ``attribute''
the revenue of a user to every referrer along the chain of referrals ending at
that user. For example, if \(a\) referred \(b\) who referred \(c\) and \(c\)
generated \$210 of revenue, then \$140 is attributed to \(b\) and 70 to \(a\).
Note that the distribution of c's revenue depends on the length of the referral
chain ending at \(c\). So, if \(d\) had referred \(a\) in this example, then
\$120 is attributed to \(b\), \$60 to \(a\) and \$30 to \(d\). 

Simply stated, the problem is to find the attributed revenue of each user.

\subsection{Selected Q operators}
See Table~\ref{tbl_q_ops}.

\begin{table}[ht]
\centering
\begin{tabular}{|l|l|l|} \hline \hline
{\bf ID} & {\bf operator} & {\bf explanation} \\ \hline \hline
1 & \(y = \mathrm{get\_val\_by\_idx}(f, x)\) & \(y_i \leftarrow x_{f_i}\) \\ \hline
2 & \(y = \mathrm{set\_sclr\_val\_by\_idx}(x, y, s)\) & \(x_i = j \Rightarrow y_j \leftarrow s\) \\ \hline
3 & \(z = \mathrm{add\_vec\_val\_by\_idx}(x, y, z)\) & \(x_i = j \Rightarrow z_j \leftarrow
z_j + y_i\) \\ \hline
4 & \(z = \mathrm{vvmul}(x, y)\) & \(z_i \leftarrow x_i \times y_i\) \\ \hline
5 & \(y = \mathrm{vsleq}(x, s)\) & {\bf if} \(x_i \leq s\) {\bf then} \(y_i \leftarrow 1\) {\bf else} \(y_i \leftarrow 0\)  \\ \hline
6 & \(w = \mathrm{ifxthenyelsez}(x, y,z)\) & {\bf if} \(x_i\) {\bf then} \(w_i \leftarrow y_i\) {\bf else} \(w_i \leftarrow z_i\)  \\ \hline
7 & \(x = \mathrm{const}(s)\) & \(x_i \leftarrow s\) \\ \hline
8 & \(z = \mathrm{where}(x, y)\) & \(z = \{x_i\}\) where \(y_i = 1\) \\ \hline
\hline
\end{tabular}
\caption{Selected Q operators}
\label{tbl_q_ops}
\end{table}

\section{Data Structures}
\subsection{T0}

\(T_0\) has the following columns, where each row refers to a person.
\be
\item \(x\) --- a sequence \(0, 1, \ldots\)
\item \(y\), person who did the referring. 
\item id, original ID 
\item \(r\), dollar amount spent 
\item \(s\), dollar amount attributed, {\em created by algorithm}
\item \(d\), max depth of referral chain ending in this person, {\em created by algorithm}
\ee
Notes:
\bi
\item \(y[i] = j \Rightarrow\) \(i\) was referred by \(j\). 
We also say that \(y\) is the 1-parent of \(i\)
\item \(y[j] < 0 \Rightarrow \) nobody referred \(j\)
\item a person can be referred by at most one person 
\ei

\subsection{T1}

\(T_1\) is \(T_0\) restricted to persons who were refered. Specifically,
\bi
\item \(v = \mathbf{Q.vsgeq}(T_0.y, 0)\)
\item \(T_1.x = \mathbf{Q.where}(T_0.x, v)\)
\item \(T_1.y = \mathbf{Q.where}(T_0.y, v)\)
%% DELETE \item \(T_1.r = \mathbf{Q.where}(T_0.r, v)\)
%% DELETE \item \(T_1.d = \mathbf{Q.const}(1)\) 
%% DELETE --- initial assumption on depth of chain ending in \(x\)
\ei

\subsection{Tk}

Tables \(T_k\) for \(k =  2, \ldots\) have the following columns
\be
\item \(x\), person who was referred
\item \(y\), person who did the referring at a distance of \(k\)
\ee

Note that if \(a\) referred \(b\) and \(b\) referred \(c\), then table \(T_2\)
would have a row of the form \((c, a)\)

\subsection{Sample Data}
An example is in Table~\ref{example_extend}. 
\begin{table}[hp]
\centering
\begin{tabular} {|l|l|l|l|l|} \hline \hline
{\bf k} & {\bf x} & {\bf y} & {\bf z} & {\bf w} \\ \hline
0 & 0 & 1  & --- & --- \\ \hline
0 & 1 & 2  & --- & --- \\ \hline
0 & 2 & 3  & --- & --- \\ \hline
0 & 3 & 4  & --- & --- \\ \hline
0 & 4 & -1 & --- & --- \\\hline
0 & 5 & 6  &  --- & --- \\\hline
0 & 6 & 7  &  --- & --- \\\hline
0 & 7 & -1 &  --- & --- \\\hline
0 & 8 & -1 &  --- & --- \\\hline
\hline  \hline
1 & 0 & 1  & 2  & 1 \\ \hline
1 & 1 & 2  & 3  & 1 \\ \hline
1 & 2 & 3  & 4  & 1 \\ \hline
1 & 3 & 4  & -1 & 0 \\ \hline
1 & 5 & 6  & 2  & 1 \\ \hline
1 & 6 & 7  & -1 & 0 \\ \hline
\hline  \hline
2 & 0 & 2 & 3 & 1 \\ \hline
2 & 1 & 3 & 4 & 1 \\ \hline
2 & 2 & 4 & -1 & 0 \\ \hline
2 & 5 & 7 & -1 & 0 \\ \hline
\hline  \hline
3 & 0 & 3 & 4 & 1 \\ \hline
3 & 1 & 4 & -1 & 0 \\ \hline
\hline  \hline
4 & 0 & 4 & -1 & 0 \\ \hline
\end{tabular}
\caption{Sample data}
\label{example_extend}
\end{table}


\section{Algorithm}

The algorithm is presented in Figure~\ref{algo}. Some useful routines in
Section~\ref{aux_algo}
\subsection{Sub-routines}
\label{aux_algo}

\bi
\item The function {\bf Q.extend} is in Figure~\ref{extend}
\item The way the attribution diminishes with distance is in Table~\ref{attenuate}
\ei

\begin{figure}
\centering
\fbox{
\begin{minipage}{12 cm}
\centering
\begin{tabbing} 
\hspace*{0.25in} \= \hspace*{0.25in} \= \hspace*{0.25in} \= \kill
Inputs: \+ \\
\(T_k.x\) \\
\(T_k.y\) \\
\(T_0.y\) \- \\
% Operation:  \+ \\
% Let \(T_k.x[i] = x', T_k.y[i] = y'\).  \\
% Let \(f' = T_0.y[y']\).  \\
% If \(z' \geq 0\), add \((x', z')\) to output; else, do nothing \- \\
Implementation in Q:  \+ \\
\(z = \mathbf{Q.get\_val\_by\_idx}(T_k.y, T_0.y)\) \\
\(w = \mathbf{Q.vsgeq}(z, 0)\) \\
\(T_{k+1}.x = \mathbf{Q.where}(T_k.x, w)\) \\
\(T_{k+1}.y = \mathbf{Q.where}(z, w)\) \- \\
\end{tabbing}
\caption{extend}
\label{extend}
\end{minipage}
}
\end{figure}


\begin{table}[hp]
\centering
\begin{tabular}{|l|l|l|l|l|l|l|} \hline \hline
\(d_{max}\) & \(\alpha_1\)  & \(\alpha_2\)  & \(\alpha_3\)  & \(\alpha_4\)
\\ \hline
1 & 1 & --- & --- & --- \\ \hline
2 & 2/3 & 1/3 & --- & --- \\ \hline
3 & 4/7 & 2/7 & 1/7 & --- \\ \hline
4 & 8/15 & 4/15 & 2/15 & 1/15 \\ \hline
\hline
\end{tabular}
\caption{Attenuation Factors for different \(d, d_{max}\)}
\label{attenuate}
\end{table}


\begin{figure}
\centering
\fbox{
\begin{minipage}{12 cm}
\centering
\begin{tabbing} 
\hspace*{0.25in} \= \hspace*{0.25in} \= \hspace*{0.25in} \= \kill

\(T_0.d = \mathbf{Q.const}(1)\) --- initialize max depth to 1 \\
\(T_0.s = \mathbf{Q.const}(0)\) --- initialize attributed revenue to 0 \\
\(k = 1\) \\
{\bf repeat } \+ \\
\(T_{k+1} = \mathbf{Q.extend}(T_k.x, T_k.y, T_0.y)\) (Figure~\ref{extend})\\
{\bf if} \(T_{k+1} = \bot\) {\bf then break else} \(k = k+1\) {\bf end}\\
--- Update max depth of referral chain \\
\(\mathbf{Q.set\_sclr\_val\_by\_idx}(T_{k+1}.x, T_0.d, k+1)\) \- \\
{\bf until} --- not possible to extend any further \\
\(d_{max} = k\) \\
Load \(\alpha\) which contains attribution coefficients (Table~\ref{attenuate})\\
{\bf for} \(k = 1, \ldots d_{max}\) {\bf do} \+ \\
% {\bf for} \(k = 1, \ldots k\) {\bf do} \+ \\
  \(T_k.d       = \mathbf{Q.get\_val\_by\_idx}(T_k.x, T_0.d)\)  \\
  \(T_k.r       = \mathbf{Q.get\_val\_by\_idx}(T_k.x, T_0.r)\)  \\
  \(T_k.\alpha  = \mathbf{Q.get\_val\_by\_idx}(T_k.d, \alpha[k])\) \\
  \(s           = \mathbf{Q.vvadd}(T[k].r, T[k].\alpha)\) \\
  \(\mathbf{Q.add\_vec\_val\_by\_idx}(s, T_k.y, T_0.s)\) \- \\
{\bf endfor} \\
\end{tabbing}
\caption{Pseudo-code}
\label{algo}
  \end{minipage}
}
\end{figure}

\newpage

\appendix
Some bogus reference to make bibtex not complain \cite{Hastie2009}.
\bibliographystyle{alpha}
\bibliography{../../../DOC/ref}
