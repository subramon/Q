return require 'Q/UTILS/lua/code_gen' {
   declaration = [[
#include <omp.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "f1f2opf3_concat.h"
//START_FOR_CDEF
extern int
${fn}(  
      ${f1_ctype} * const restrict in1,  
      ${f2_ctype} * const restrict in2,  
      uint32_t nR,  
      f1f2opf3_concat_t *ptr_args,
      ${f3_ctype} * restrict out 
      ) 
;
//STOP_FOR_CDEF
   ]],
   definition = [[

#include "${fn}.h"
#include "${fn_ispc}.h"

int
${fn}(  
      ${f1_ctype} * const restrict in1,  
      ${f2_ctype} * const restrict in2,  
      uint32_t nR,  
      f1f2opf3_concat_t *ptr_args,
      ${f3_ctype} * restrict out 
      )

{ 
  int status = 0;
  int shift_by = ptr_args->shift_by;
  uint32_t nT = omp_get_num_threads();
  uint32_t n = (nR / nT ) * nT;
  uint32_t n_per_core = n / nT;
#pragma omp parallel for schedule(static)
  for ( uint32_t i = 0; i < nT; i++ ) {  
    uint32_t lb = i * n_per_core;
    ${fn_ispc}(in1+lb, in2+lb, out+lb, n_per_core, shift_by);
  }

  // handle the balance 
  for ( uint32_t i = n; i < nR; i++ ) {  
    uint64_t    inv1 = in1[i]; 
    uint64_t    inv2 = in2[i]; 
    uint64_t    outv;
    outv = ( inv1 << shift_by ) | inv2;
    out[i] = outv;
  } 

  return status;
}

   ]]
}
