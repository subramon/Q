return require 'Q/UTILS/lua/code_gen' {

   declaration = [[

#include "q_incs.h"

typedef struct _reduce_${op}_${qtype}_args {
  ${reduce_ctype} ${op}_val;
  uint64_t num; // number of non-null elements inspected
  int64_t ${op}_index; // storing min value index (signed integer)
  } REDUCE_${op}_${qtype}_ARGS;
  
${includes}
extern int
${fn}(  
      const ${ctype} * restrict in,  
      uint64_t nR,
      void *ptr_args,
      uint64_t offset
      ) 
;

   ]],
   definition = [[

#include "_${fn}.h"
#include <omp.h>

int
${fn}(  
      const ${ctype} * restrict in,
      uint64_t nR,  
      void *in_ptr_args,
      uint64_t offset
      )

{
  int status = 0;
  ${ctype} inv; 
  REDUCE_${op}_${qtype}_ARGS *ptr_args;
  ptr_args = (REDUCE_${op}_${qtype}_ARGS *)in_ptr_args;

  if ( offset == 0 ) {
    ptr_args->${op}_val = ${initial_val};
    ptr_args->num     = 0;
    ptr_args->${op}_index = -1;
  }
  
  ${reduce_ctype} curr_val = ptr_args->${op}_val;
  int64_t curr_index       = ptr_args->${op}_index;
  uint32_t num_threads     = sysconf(_SC_NPROCESSORS_ONLN);

  ${reduce_ctype} ${op}_val = ${initial_val};
  uint64_t block_size = nR / num_threads;
#pragma omp parallel for schedule(static)
  for ( uint32_t t = 0; t < num_threads; t++ ) { 
    uint64_t lb = t * block_size;
    uint64_t ub = lb + block_size;
    if ( t == (num_threads-1) ) { ub = nR; }
    ${reduce_ctype} lval = ${initial_val};
    ${reduce_ctype} val = ${initial_val};
    int64_t lindex = -1;
    for ( uint64_t i  = lb; i < ub; i++ ) {  
      inv = in[i];
      val = ${reducer}(lval, inv);
      if (val != lval){
        lval = val;
        lindex = i + offset;
      }
    }
#pragma omp critical (_${fn})
    {
      if ( lval ${comparator} curr_val ) {
        if ( curr_index < 0 ) {
          curr_index = lindex;
        }
        else if ( lval != curr_val ) { 
          curr_index = lindex;
        }
        else if ( lindex < curr_index ) { /* note lval == curr_val here */
          curr_index = lindex;
        }
        curr_val = lval;
      }
    }
  }
  ptr_args->${op}_val = curr_val;
  ptr_args->${op}_index = curr_index;
  ptr_args->num     += nR;
  return status;
}
   ]]
}
