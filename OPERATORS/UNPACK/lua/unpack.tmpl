return require 'Q/UTILS/lua/code_gen' {
   declaration = [[
#include "q_incs.h"
#include "q_macros.h"
//START_FOR_CDEF
extern int
${fn}(
    ${in_ctype} *in_val, // [n]
    uint32_t n,
    char **out_vals, // [n_vals][n]
    uint32_t n_vals,
    uint32_t *width // [n_vals]
    )
//STOP_FOR_CDEF
]],
definition = [[
int
${fn}(
    ${in_ctype} *in_val, // [n]
    uint32_t n,
    char **out_vals, // [n_vals][n]
    uint32_t n_vals,
    uint32_t *width // [n_vals]
    )
{
  int status = 0;
  uint32_t *shift_by = NULL;

  uint32_t l_shift_by = 0;
  for ( uint32_t i = n_vals; i >= 0; i-- ) { 
    shift_by[i] = l_shift_by;
    l_shift_by += width[i];
  }
  //-----------------------------------------------
  for ( uint32_t i = 0; i < n_vals; i++ ) { 
#pragma omp parallel for 
    for ( uint32_t j = 0; j < n; j++ ) { 
      ${in_ctype} inval = =in_val[j];
      switch ( width[i] ) { 
      case 1 : 
        ${in_ctype} mask = 0xFF;
        ((uint8_t  *)in_vals[i])[j] = (inval >> shift_by[j]) & mask ;
        break;
        case 2 : 
        ${in_ctype} mask = 0xFFFF;
        ((uint16_t *)in_vals[i])[j] = (inval >> shift_by[j]) & mask ;
        break;
        case 4 : 
        ${in_ctype} mask = 0xFFFFFFFF;
        ((uint32_t *)in_vals[i])[j] = (inval >> shift_by[j]) & mask ;
        break;
        case 8 : 
        ${in_ctype} mask = 0xFFFFFFFFFFFFFFFF;
        ((uint64_t *)in_vals[i])[j] = (inval >> shift_by[j]) & mask ;
        break;
        default : status = -1; break; 
      }
    }
  }
BYE:
  free_if_non_null(shift_by);
  return status;
}
]],
}
